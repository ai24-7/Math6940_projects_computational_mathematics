import random

def generate_ampl_data(num_tasks=60, num_servers=4, output_file='dataset_model3_nov30.dat'):
    # Define sets
    tasks = [f't{i}' for i in range(1, num_tasks + 1)]
    servers = [f's{j}' for j in range(1, num_servers + 1)]
    resources = ['GPU', 'CPU', 'Memory', 'Storage']
    
    # Initialize data structures
    w = {}
    e = {}
    p = {}
    S_time = {}
    d = {}
    r = {}

    # Priority weights
    for task in tasks:
        w[task] = random.randint(1, 5)
    
    # Energy consumption rates
    for server in servers:
        e[server] = random.randint(5, 15)
    
    # Resource capacities
    r = {server: {} for server in servers}
    for server in servers:
        for resource in resources:
            r[server][resource] = random.randint(50, 100)
    
    # Resource demands
    d = {task: {} for task in tasks}
    for task in tasks:
        for resource in resources:
            # Generate demands that are significantly less than capacities
            # This helps ensure that tasks can fit on servers
            max_demand = min(r[server][resource] for server in servers) // 4
            d[task][resource] = random.randint(1, max_demand)
    
    # Processing times and setup times
    p = {}
    S_time = {}
    for task in tasks:
        p[task] = {}
        S_time[task] = {}
        for server in servers:
            p[task][server] = random.randint(1, 10)
            S_time[task][server] = random.randint(0, 3)
    
    # Feasibility Checks
    # 1. Total Demand â‰¤ Total Capacity for each resource
    total_demand = {resource: 0 for resource in resources}
    total_capacity = {resource: 0 for resource in resources}
    for resource in resources:
        total_demand[resource] = sum(d[task][resource] for task in tasks)
        total_capacity[resource] = sum(r[server][resource] for server in servers)
        if total_demand[resource] > total_capacity[resource]:
            print(f"Adjusting demands for resource {resource} to ensure feasibility.")
            # Scale down demands proportionally
            scaling_factor = total_capacity[resource] / total_demand[resource]
            for task in tasks:
                d[task][resource] = max(1, int(d[task][resource] * scaling_factor))
            # Recalculate total demand
            total_demand[resource] = sum(d[task][resource] for task in tasks)
    
    # 2. Ensure each task can be assigned to at least one server
    for task in tasks:
        assignable = False
        for server in servers:
            can_assign = all(d[task][resource] <= r[server][resource] for resource in resources)
            if can_assign:
                assignable = True
                break
        if not assignable:
            print(f"Adjusting demands for task {task} to ensure it can be assigned.")
            # Adjust demands to fit the smallest capacity server
            for resource in resources:
                min_capacity = min(r[server][resource] for server in servers)
                d[task][resource] = min(d[task][resource], min_capacity)
    
    # Write data to file
    with open(output_file, 'w') as f:
        f.write("# ---------------------------------------------------\n")
        f.write("# Data File for Task Assignment to Servers Model\n")
        f.write("# Generated by generate_data.py\n")
        f.write("# ---------------------------------------------------\n\n")
        
        # Sets
        f.write("# Sets\n")
        f.write(f"set T := {' '.join(tasks)};\n")
        f.write(f"set S := {' '.join(servers)};\n")
        f.write(f"set R := {' '.join(resources)};\n\n")
        
        # Parameters
        
        # Priority weights
        f.write("# Parameters\n")
        f.write("# Priority weight of each task\n")
        f.write("param w :=\n")
        for task in tasks:
            f.write(f"    {task} {w[task]}\n")
        f.write(";\n\n")
        
        # Energy consumption rates
        f.write("# Energy consumption rate of each server\n")
        f.write("param e :=\n")
        for server in servers:
            f.write(f"    {server} {e[server]}\n")
        f.write(";\n\n")
        
        # Processing times
        f.write("# Processing time of each task on each server\n")
        f.write("param p :=\n")
        for task in tasks:
            for server in servers:
                f.write(f"    {task} {server} {p[task][server]}\n")
        f.write(";\n\n")
        
        # Setup times
        f.write("# Setup time between tasks on servers\n")
        f.write("param S_time :=\n")
        for task in tasks:
            for server in servers:
                f.write(f"    {task} {server} {S_time[task][server]}\n")
        f.write(";\n\n")
        
        # Resource demands
        f.write("# Demand of each resource by each task\n")
        f.write("param d :=\n")
        for task in tasks:
            for resource in resources:
                f.write(f"    {task} {resource} {d[task][resource]}\n")
        f.write(";\n\n")
        
        # Resource capacities
        f.write("# Capacity of each resource on each server\n")
        f.write("param r :=\n")
        for server in servers:
            for resource in resources:
                f.write(f"    {server} {resource} {r[server][resource]}\n")
        f.write(";\n\n")
        
        # Scaling coefficients and large constant
        f.write("# Scaling coefficients and large constant\n")
        f.write("param alpha := 0.5;\n")
        f.write("param beta  := 0.3;\n")
        f.write("param M     := 1000;\n\n")
        
        f.write("# ---------------------------------------------------\n")
        f.write("# End of Data File\n")
        f.write("# ---------------------------------------------------\n")

    print(f"Data file '{output_file}' generated successfully with {num_tasks} tasks and {num_servers} servers.")

if __name__ == "__main__":
    generate_ampl_data()

